\section{Digital}
\subsubsection*{PWM Motor Control} 
Instead of applying a constant voltage across a DC motor, we repeatedly switch the motor on and off with a fixed voltage applied to the motor. This is done by sending PWM (Pulse Width Modulation) pulses to power the MOSFET in order to turn it on and off. Then, the motor sees the average voltage while it depends on duty cycle of PWM pulses. The speed of rotation is proportion to this average voltage. By PWM method, it’s easier to control the DC motor speed rather than by directly controlling the voltage across it. All we have to do is to modulate pulse width, in other words, a duty cycle. Also, a power MOSFET consumes only negligible power in switching. PSoC has built in PWM modules which allows for simple motor speed control using PWM.

\subsubsection*{Path Finding Algorithms}
To find the path to a particular destination, we considered algorithms such as Breadth First Search (BFS), Depth First Search (DFS), Dijkstra’s algorithm and the A* algorithm.
\\DFS is a traversal algorithm that uses the idea of backtracking. It involves exhaustive searches of all the nodes/vertices by going ahead until the depth of the current path is reached, you then backtrack to the previous intersection to find further unvisited nodes to traverse. This is repeated until the destination is found or all nodes have been visited. The problems with DFS are that we can't find the optimal shortest path and that the algorithm leads to subpar performance for our use case. Also, the maze is modelled as an unweighted graph which can contain cycles, we have to ensure that the nodes that are visited are marked to prevent visiting the same node more than once so that it doesn't end up in an infinite loop. Due to the unpredictable nature of DFS, it was used to implement mode one.
\\As the maze is modelled as an unweighted graph, we considered BFS, Dijkstra’s and A* for the finding the shortest path. BFS is a traversal algorithm where you start traversing from a source node and traverse the graph at the present depth thus exploring the neighbour nodes.  You must then move towards the next-level neighbour nodes. This is repeated until the destination node is found. Like DFS, we must ensure that the visited nodes are marked to prevent visiting the same node more than once so that it doesn't end up in an infinite loop. Dijkstra's algorithm functionally is like BFS. The difference between them is the order in which nodes are considered. Where BFS will consider all edges from a single node before moving on to other nodes, while Dijkstra's algorithm will always consider the lowest-weight unseen edge, from the set of edges connected to all nodes that have been seen so far. The A* algorithm is an implementation that extends Dijkstra’s algorithm. However, instead of only using the weight to select which vertices to explore next, A* greedily chooses the next node using the weight (in our case the weight is always one) and a heuristic. For our project the robot can only move in four directions in the maze therefore we chose an admissible heuristic in the Manhattan distance as our heuristic function. BFS has a time complexity of $O(V+E)$, Dijkstra's has a time complexity of $O(V^2)$ and A* has a time complexity of $O(E)$ where V and E are the vertices and edges in the graph respectively. Therefore, for mode two, the A* algorithm was used.
\\For both mode one and two, the robot then utilises these algorithms to map out the entire path it will travel to collect all the pellets. The nodes of the entire path are then stored in an array. Refer to Appendix F, for more details about the algorithms.


\subsubsection*{Line Following Method}
To follow a line, two line sensors are used. Initially, our method for following a line would involve reversing the polarity of one wheel when the line sensor of the same side started to veer into the black line. This meant our forward movement was jittery due to the wheels swinging back and forth, which ultimately caused issues when turning due to entering intersections on an angle . Our new method adjusts the PWM of one wheel by a set value instead. This allowed for a smoother motion, fixing our aforementioned issue with turning. Refer to Appendix F: Figure 27 for more detail.

\subsubsection*{Data structure and Data Management}
Our robot is reliant on the projected map in order to traverse it. Due to this, the overall system is reactive, taking in many processed data inputs from the environment constantly. In order to maximise the computation time and minimise unnecessary resource usage, we thought carefully about the data structures used and  how our data is managed.
\\The main data structure to store our data are 1D and 2D arrays. Alternative data structures were considered such as linked lists or queues. However, an array would be a more sensible option for our application as accessing a specific element has a time complexity of $O(1)$ as opposed to $O(n)$ of a linked list, refer to Appendix A: Table 3. Arrays require less memory, and are quicker to access specific data than the aforementioned data structures. Though arrays are static and require us to know its size during instantiation, we know the size of our data thus only the minimum required memory will be allocated. Also, our implementation does not require us to modify the size of the array, thus we do not need unnecessary features the other data structures offer.
\\The system utilises a PSoC thus it is in our best interest to maximise the use of our limited memory. In terms of data types, the smallest precision was used where appropriate to minimise memory usage. For instance, any flag variables used to signify an event was set as an uint8 data type since we do not need precision beyond 8 bits.

\subsubsection*{RF/Implementation}
In order to implement the algorithms mentioned above, we need to be able to track the position of our robot. However, in our algorithm, we only need to monitor the position of the robot constantly when the robot needs to stop in the middle of a path. In all other cases, we only need to know when the robot reaches an event such as an intersection or dead end. In other words, whilst the RF transmission of our position could improve our accuracy, it is unnecessary in our implementation of traversing. Aside from the additional resources required to process the RF, another problem is that our system would be reliant on RF to reaffirm our position. Ignoring the corner cases where the RF transmission sends incorrect data, the timing of the RF transmission is simply too inconsistent for the rate at which we plan to operate at.

\subsubsection*{Testing \& Verification}
Similar to the analogue design, the algorithms were verified and tested before they were implemented on the robot. For our path finding algorithms, the algorithms were coded in a separate environment and tested before optimising and porting it over to the PSoC Creator environment. By developing the algorithm in a separate environment, we are able to test the code much more efficiently by effectively isolating the algorithm, ensuring the correct path is generated. To test the algorithms, the code was compiled using a Command Line Interface (CLI) thus we are able to log each vital step of the algorithm and confirm it aligns with what we expect. A visual representation of the states can also be printed out for accessibility when testing.
\\Once ported over, we had to implement the path finding algorithms with our robot. This part of the project was difficult due to the need to synchronise the algorithms with the movement of the robot and the light sensing circuits. When unexpected behaviour occurred during testing, we followed a procedure until the problem was found. The purpose of procedure was to ensure testing was as efficient as possible by isolating the problem, using a given hierarchy. The order of the procedure is as follows; Repeat the test a few times, ensure the light sensors are working, and incrementally test the state logic of the code.  The first step ensures the bug can be reproduced thus can be fixed in a reasonable timeframe. The second step verifies that the problem is not a prototyping issue but rather a logic issue. Finally, based on the previous steps, we can infer the problem is indeed a logic issue thus debug the code.